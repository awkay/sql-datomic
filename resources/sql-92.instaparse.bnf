(* Based off of http://savage.net.au/SQL/sql-92.bnf *)

direct_SQL_statement ::=
             direct_SQL_data_statement
     |       SQL_schema_statement
     |       SQL_transaction_statement
     |       SQL_connection_statement
     |       SQL_session_statement
     |       direct_implementation_defined_statement


SQL_terminal_character ::=
                         SQL_language_character
                       | SQL_embedded_language_character

SQL_language_character ::=
                simple_Latin_letter
        |       digit
        |       SQL_special_character

simple_Latin_letter ::=
                simple_Latin_upper_case_letter
        |       simple_Latin_lower_case_letter

simple_Latin_upper_case_letter ::=
                                   "A" | "B" | "C" | "D" | "E" | "F"
                                 | "G" | "H" | "I" | "J" | "K" | "L"
                                 | "M" | "N" | "O" | "P" | "Q" | "R"
                                 | "S" | "T" | "U" | "V" | "W" | "X"
                                 | "Y" | "Z"

simple_Latin_lower_case_letter ::=
                                   "a" | "b" | "c" | "d" | "e" | "f"
                                 | "g" | "h" | "i" | "j" | "k" | "l"
                                 | "m" | "n" | "o" | "p" | "q" | "r"
                                 | "s" | "t" | "u" | "v" | "w" | "x"
                                 | "y" | "z"

digit ::= #'\d'

SQL_special_character ::=
                <space>
        |       double_quote
        |       percent
        |       ampersand
        |       quote
        |       left_paren
        |       right_paren
        |       asterisk
        |       plus_sign
        |       comma
        |       minus_sign
        |       period
        |       solidus
        |       colon
        |       semicolon
        |       less_than_operator
        |       greater_than_operator
        |       equals_operator
        |       question_mark
        |       underscore
        |       vertical_bar

<space> ::= #'\s+'
<zspace> ::= #'\s*'

double_quote ::= "\""

percent ::= "%"

ampersand ::= "&"

quote ::= "'"

left_paren ::= "("

right_paren ::= ")"

asterisk ::= "*"

plus_sign ::= "+"

comma ::= ","

minus_sign ::= "-"

period ::= "."

solidus ::= "/"

colon ::= ":"

semicolon ::= ";"

less_than_operator ::= "<"

equals_operator ::= "="

greater_than_operator ::= ">"

question_mark ::= "?"

underscore ::= "_"

vertical_bar ::= "|"

SQL_embedded_language_character ::= left_bracket | right_bracket

left_bracket ::= "["

right_bracket ::= "]"

token ::=
                nondelimiter_token
        |       delimiter_token

nondelimiter_token ::=
                regular_identifier
        |       key_word
        |       unsigned_numeric_literal
        |       national_character_string_literal
        |       bit_string_literal
        |       hex_string_literal

regular_identifier ::= identifier_body

identifier_body ::= #'\w+'

(*
identifier_body ::= identifier_start [ { underscore | identifier_part } "+" ]

identifier_start ::= !! See the Syntax rules

identifier_part ::= identifier_start | digit
*)


key_word ::= reserved_word | non_reserved_word

reserved_word ::=
 "ABSOLUTE" | "ACTION" | "ADD" | "ALL" | "ALLOCATE" | "ALTER" | "AND" | "ANY" | "ARE"
 | "AS" | "ASC" | "ASSERTION" | "AT" | "AUTHORIZATION" | "AVG"
 | "BEGIN" | "BETWEEN" | "BIT" | "BIT_LENGTH" | "BOTH" | "BY"
 | "CASCADE" | "CASCADED" | "CASE" | "CAST" | "CATALOG" | "CHAR" | "CHARACTER" | "CHARACTER_LENGTH"
 | "CHAR_LENGTH" | "CHECK" | "CLOSE" | "COALESCE" | "COLLATE" | "COLLATION" | "COLUMN" | "COMMIT"
 | "CONNECT" | "CONNECTION" | "CONSTRAINT" | "CONSTRAINTS" | "CONTINUE" | "CONVERT" | "CORRESPONDING"
 | "CREATE" | "CROSS" | "CURRENT" | "CURRENT_DATE" | "CURRENT_TIME" | "CURRENT_TIMESTAMP" | "CURRENT_USER" | "CURSOR"
 | "DATE" | "DAY" | "DEALLOCATE" | "DEC" | "DECIMAL" | "DECLARE" | "DEFAULT"
 | "DEFERRABLE" | "DEFERRED" | "DELETE" | "DESC" | "DESCRIBE" | "DESCRIPTOR" | "DIAGNOSTICS"
 | "DISCONNECT" | "DISTINCT" | "DOMAIN" | "DOUBLE" | "DROP"
 | "ELSE" | "END" | "END-EXEC" | "ESCAPE" | "EXCEPT" | "EXCEPTION" | "EXEC" | "EXECUTE" | "EXISTS" | "EXTERNAL" | "EXTRACT"
 | "FALSE" | "FETCH" | "FIRST" | "FLOAT" | "FOR" | "FOREIGN" | "FOUND" | "FROM" | "FULL"
 | "GET" | "GLOBAL" | "GO" | "GOTO" | "GRANT" | "GROUP"
 | "HAVING" | "HOUR"
 | "IDENTITY" | "IMMEDIATE" | "IN" | "INDICATOR" | "INITIALLY" | "INNER" | "INPUT" | "INSENSITIVE"
 | "INSERT" | "INT" | "INTEGER" | "INTERSECT" | "INTERVAL" | "INTO" | "IS" | "ISOLATION"
 | "JOIN"
 | "KEY"
 | "LANGUAGE" | "LAST" | "LEADING" | "LEFT" | "LEVEL" | "LIKE" | "LOCAL" | "LOWER"
 | "MATCH" | "MAX" | "MIN" | "MINUTE" | "MODULE" | "MONTH"
 | "NAMES" | "NATIONAL" | "NATURAL" | "NCHAR" | "NEXT" | "NO" | "NOT" | "NULL" | "NULLIF" | "NUMERIC"
 | "OCTET_LENGTH" | "OF" | "ON" | "ONLY" | "OPEN" | "OPTION" | "OR" | "ORDER" | "OUTER" | "OUTPUT" | "OVERLAPS"
 | "PAD" | "PARTIAL" | "POSITION" | "PRECISION" | "PREPARE" | "PRESERVE" | "PRIMARY" | "PRIOR" | "PRIVILEGES" | "PROCEDURE" | "PUBLIC"
 | "READ" | "REAL" | "REFERENCES" | "RELATIVE" | "RESTRICT" | "REVOKE" | "RIGHT" | "ROLLBACK" | "ROWS"
 | "SCHEMA" | "SCROLL" | "SECOND" | "SECTION" | "SELECT" | "SESSION" | "SESSION_USER" | "SET"
 | "SIZE" | "SMALLINT" | "SOME" | "SPACE" | "SQL" | "SQLCODE" | "SQLERROR" | "SQLSTATE" | "SUBSTRING" | "SUM" | "SYSTEM_USER"
 | "TABLE" | "TEMPORARY" | "THEN" | "TIME" | "TIMESTAMP" | "TIMEZONE_HOUR" | "TIMEZONE_MINUTE"
 | "TO" | "TRAILING" | "TRANSACTION" | "TRANSLATE" | "TRANSLATION" | "TRIM" | "TRUE"
 | "UNION" | "UNIQUE" | "UNKNOWN" | "UPDATE" | "UPPER" | "USAGE" | "USER" | "USING"
 | "VALUE" | "VALUES" | "VARCHAR" | "VARYING" | "VIEW"
 | "WHEN" | "WHENEVER" | "WHERE" | "WITH" | "WORK" | "WRITE"
 | "YEAR"
 | "ZONE"

non_reserved_word ::=
             "ADA"
     |       "C" | "CATALOG_NAME" | "CHARACTER_SET_CATALOG" | "CHARACTER_SET_NAME" | "CHARACTER_SET_SCHEMA"
     |       "CLASS_ORIGIN" | "COBOL" | "COLLATION_CATALOG" | "COLLATION_NAME" | "COLLATION_SCHEMA"
     |       "COLUMN_NAME" | "COMMAND_FUNCTION" | "COMMITTED" | "CONDITION_NUMBER" | "CONNECTION_NAME"
     |       "CONSTRAINT_CATALOG" | "CONSTRAINT_NAME" | "CONSTRAINT_SCHEMA" | "CURSOR_NAME"
     |       "DATA" | "DATETIME_INTERVAL_CODE" | "DATETIME_INTERVAL_PRECISION" | "DYNAMIC_FUNCTION"
     |       "FORTRAN"
     |       "LENGTH"
     |       "MESSAGE_LENGTH" | "MESSAGE_OCTET_LENGTH" | "MESSAGE_TEXT" | "MORE" | "MUMPS"
     |       "NAME" | "NULLABLE" | "NUMBER"
     |       "PASCAL" | "PLI"
     |       "REPEATABLE" | "RETURNED_LENGTH" | "RETURNED_OCTET_LENGTH" | "RETURNED_SQLSTATE" | "ROW_COUNT"
     |       "SCALE" | "SCHEMA_NAME" | "SERIALIZABLE" | "SERVER_NAME" | "SUBCLASS_ORIGIN"
     |       "TABLE_NAME" | "TYPE"
     |       "UNCOMMITTED" | "UNNAMED"

unsigned_numeric_literal ::=
             exact_numeric_literal
     |       approximate_numeric_literal

exact_numeric_literal ::=
             unsigned_integer [ period [ unsigned_integer ] ]
     |       period unsigned_integer

unsigned_integer ::= digit+

approximate_numeric_literal ::=
             mantissa "E" exponent

mantissa ::= exact_numeric_literal

exponent ::= signed_integer

signed_integer ::= [ sign ] unsigned_integer

sign ::= plus_sign | minus_sign

national_character_string_literal ::=
             "N" quote [ character_representation+ ] quote [ { separator+ quote [ character_representation+ ] quote }+ ]

character_representation ::= nonquote_character | quote_symbol

(*
nonquote_character ::= !! See the Syntax rules
*)
nonquote_character ::= #"[^']"

quote_symbol ::= quote quote

separator ::= { comment | <space> | <newline> }+

comment ::= comment_introducer [ comment_character+ ] <newline>

comment_introducer ::= minus_sign minus_sign [minus_sign+]

comment_character ::= nonquote_character | quote

(*
<newline> ::= !! implementation defined end of line indicator
*)
<newline> ::= '\n' | '\r\n'

bit_string_literal ::=
             "B" quote [ bit+ ] quote [ { separator+ quote [ bit+ ] quote }+ ]

bit ::= "0" | "1"

hex_string_literal ::=
             "X" quote [ hexit+ ] quote [ { separator+ quote [ hexit+ ] quote }+ ]

hexit ::= digit
        | "A" | "B" | "C" | "D" | "E" | "F"
        | "a" | "b" | "c" | "d" | "e" | "f"


delimiter_token ::=
             character_string_literal
     |       date_string
     |       time_string
     |       timestamp_string
     |       delimited_identifier
     |       SQL_special_character
     |       not_equals_operator
     |       greater_than_or_equals_operator
     |       less_than_or_equals_operator
     |       concatenation_operator
     |       double_period
     |       left_bracket
     |       right_bracket

character_string_literal ::=
     [ introducer character_set_specification ] quote [ character_representation+ ] quote [ { separator+ quote [ character_representation+ ] quote }+ ]

introducer ::= underscore

character_set_specification ::=
             standard_character_repertoire_name
     |       implementation_defined_character_repertoire_name
     |       user_defined_character_repertoire_name
     |       standard_universal_character_form_of_use_name
     |       implementation_defined_universal_character_form_of_use_name

standard_character_repertoire_name ::= character_set_name

character_set_name ::= [ schema_name period ] SQL_language_identifier

schema_name ::= [ catalog_name period ] unqualified_schema_name

catalog_name ::= identifier

identifier ::= [ introducer character_set_specification ] actual_identifier

actual_identifier ::= regular_identifier | delimited_identifier

delimited_identifier ::= double_quote delimited_identifier_body double_quote

delimited_identifier_body ::= delimited_identifier_part+

delimited_identifier_part ::= nondoublequote_character | doublequote_symbol

(*
nondoublequote_character ::= !! See the syntax rules
*)
nondoublequote_character ::= #'[^\"]'

doublequote_symbol ::= double_quote double_quote

unqualified_schema_name ::= identifier

SQL_language_identifier ::=
             SQL_language_identifier_start [ { underscore | SQL_language_identifier_part }+ ]

SQL_language_identifier_start ::= simple_Latin_letter

SQL_language_identifier_part ::= simple_Latin_letter | digit

implementation_defined_character_repertoire_name ::= character_set_name

user_defined_character_repertoire_name ::= character_set_name

standard_universal_character_form_of_use_name ::= character_set_name

implementation_defined_universal_character_form_of_use_name ::= character_set_name

date_string ::= quote date_value quote

date_value ::= years_value minus_sign months_value minus_sign days_value

years_value ::= datetime_value

datetime_value ::= unsigned_integer

months_value ::= datetime_value

days_value ::= datetime_value

time_string ::= quote time_value [ time_zone_interval ] quote

time_value ::= hours_value colon minutes_value colon seconds_value

hours_value ::= datetime_value

minutes_value ::= datetime_value

seconds_value ::= seconds_integer_value [ period [ seconds_fraction ] ]

seconds_integer_value ::= unsigned_integer

seconds_fraction ::= unsigned_integer

time_zone_interval ::= sign hours_value colon minutes_value

timestamp_string ::= quote date_value <space> time_value [ time_zone_interval ] quote

interval_string ::= quote { year_month_literal | day_time_literal } quote

year_month_literal ::=
             years_value
     |       [ years_value minus_sign ] months_value

day_time_literal ::= day_time_interval | time_interval

day_time_interval ::=
             days_value [ <space> hours_value [ colon minutes_value [ colon seconds_value ] ] ]

time_interval ::=
             hours_value [ colon minutes_value [ colon seconds_value ] ]
     |       minutes_value [ colon seconds_value ]
     |       seconds_value

not_equals_operator ::= "<>"

greater_than_or_equals_operator ::= ">="

less_than_or_equals_operator ::= "<="

concatenation_operator ::= "||"

double_period ::= ".."

module ::=
             module_name_clause language_clause module_authorization_clause
             [ temporary_table_declaration+ ]
             module_contents+

module_name_clause ::=
             "MODULE" <space>
             [ module_name ] <space>
             [ module_character_set_specification ]

module_name ::= identifier

module_character_set_specification ::=
     "NAMES" <space> "ARE" <space> character_set_specification

language_clause ::= "LANGUAGE" <space> language_name

language_name ::=
                  "ADA" | "C" | "COBOL" | "FORTRAN"
                | "MUMPS" | "PASCAL" | "PLI"

module_authorization_clause ::=
             "SCHEMA" <space> schema_name
     |       "AUTHORIZATION" <space> module_authorization_identifier
     |       "SCHEMA" <space> schema_name
             <space> "AUTHORIZATION"
             <space> module_authorization_identifier

module_authorization_identifier ::= authorization_identifier

authorization_identifier ::= identifier

temporary_table_declaration ::=
     "DECLARE"
     <space> "LOCAL"
     <space> "TEMPORARY"
     <space> "TABLE"
     qualified_local_table_name
     table_element_list
     [ <zspace> "ON" <space> "COMMIT" <space>
       { "PRESERVE" | "DELETE" } <space> "ROWS" ]

qualified_local_table_name ::= "MODULE" <zspace> period local_table_name

local_table_name ::= qualified_identifier

qualified_identifier ::= identifier

table_element_list ::= left_paren table_element [ { comma table_element }+ ] right_paren

table_element ::= column_definition | table_constraint_definition

column_definition ::=
             column_name { data_type | domain_name } [ default_clause ] [ column_constraint_definition+ ] [ collate_clause ]

column_name ::= identifier

data_type ::=
             character_string_type
             [ "CHARACTER" <space> "SET" <space>
               character_set_specification ]
     |       national_character_string_type
     |       bit_string_type
     |       numeric_type
     |       datetime_type
     |       interval_type

character_string_type ::=
             "CHARACTER" <zspace> [ left_paren length right_paren ]
     |       "CHAR" <zspace> [ left_paren length right_paren ]
     |       "CHARACTER" <space> "VARYING" <zspace> [ left_paren length right_paren ]
     |       "CHAR" <space> "VARYING" <zspace> [ left_paren length right_paren ]
     |       "VARCHAR" <zspace> [ left_paren length right_paren ]

length ::= unsigned_integer

national_character_string_type ::=
             "NATIONAL" <space> "CHARACTER" <zspace> [ left_paren length right_paren ]
     |       "NATIONAL" <space> "CHAR" <zspace> [ left_paren length right_paren ]
     |       "NCHAR" <zspace> [ left_paren length right_paren ]
     |       "NATIONAL" <space> "CHARACTER" <space> "VARYING" <zspace> [ left_paren length right_paren ]
     |       "NATIONAL" <space> "CHAR" <space> "VARYING" <zspace> [ left_paren length right_paren ]
     |       "NCHAR" <space> "VARYING" <zspace> [ left_paren length right_paren ]

bit_string_type ::=
             "BIT" <zspace> [ left_paren length right_paren ]
     |       "BIT" <space> "VARYING" <zspace> [ left_paren length right_paren ]

numeric_type ::=
             exact_numeric_type
     |       approximate_numeric_type

exact_numeric_type ::=
             "NUMERIC" <zspace> [ left_paren precision [ comma scale ] right_paren ]
     |       "DECIMAL" <zspace> [ left_paren precision [ comma scale ] right_paren ]
     |       "DEC" <zspace> [ left_paren precision [ comma scale ] right_paren ]
     |       "INTEGER"
     |       "INT"
     |       "SMALLINT"

precision ::= unsigned_integer

scale ::= unsigned_integer

approximate_numeric_type ::=
             "FLOAT" <zspace> [ left_paren precision right_paren ]
     |       "REAL"
     |       "DOUBLE" <space> "PRECISION"

datetime_type ::=
             "DATE"
     |   "TIME" <zspace> [ left_paren time_precision right_paren ]
         [ "WITH" <space> "TIME" <space> "ZONE" ]
     |   "TIMESTAMP" <zspace> [ left_paren timestamp_precision right_paren ]
         [ "WITH" <space> "TIME" <space> "ZONE" ]

time_precision ::= time_fractional_seconds_precision

time_fractional_seconds_precision ::= unsigned_integer

timestamp_precision ::= time_fractional_seconds_precision

interval_type ::= "INTERVAL" <space> interval_qualifier

interval_qualifier ::=
             start_field <space> "TO" <space> end_field
     |   single_datetime_field

start_field ::=
             non_second_datetime_field [ left_paren interval_leading_field_precision right_paren ]

non_second_datetime_field ::=
                            "YEAR" | "MONTH" | "DAY" | "HOUR" | "MINUTE"

interval_leading_field_precision ::= unsigned_integer

end_field ::=
             non_second_datetime_field
     |   "SECOND" <zspace> [ left_paren interval_fractional_seconds_precision right_paren ]

interval_fractional_seconds_precision ::= unsigned_integer

single_datetime_field ::=
             non_second_datetime_field [ left_paren interval_leading_field_precision right_paren ]
     |   "SECOND" <zspace> [ left_paren interval_leading_field_precision [ comma left_paren interval_fractional_seconds_precision ] right_paren ]

domain_name ::= qualified_name

qualified_name ::= [ schema_name period ] qualified_identifier

default_clause ::= "DEFAULT" <space> default_option

default_option ::=
             literal
     |       datetime_value_function
     |       "USER"
     |       "CURRENT_USER"
     |       "SESSION_USER"
     |       "SYSTEM_USER"
     |       "NULL"

literal ::= signed_numeric_literal | general_literal

signed_numeric_literal ::= [ sign ] unsigned_numeric_literal

general_literal ::=
             character_string_literal
     |       national_character_string_literal
     |       bit_string_literal
     |       hex_string_literal
     |       datetime_literal
     |       interval_literal

datetime_literal ::=
             date_literal
     |       time_literal
     |       timestamp_literal

date_literal ::= "DATE" <space> date_string

time_literal ::= "TIME" <space> time_string

timestamp_literal ::= "TIMESTAMP" <space> timestamp_string

interval_literal ::= "INTERVAL" <space> [ sign ] <zspace> interval_string <zspace> interval_qualifier

datetime_value_function ::=
             current_date_value_function
     |       current_time_value_function
     |       current_timestamp_value_function

current_date_value_function ::= "CURRENT_DATE"

current_time_value_function ::= "CURRENT_TIME" <zspace> [ left_paren time_precision right_paren ]

current_timestamp_value_function ::= "CURRENT_TIMESTAMP" <zspace> [ left_paren timestamp_precision right_paren ]

column_constraint_definition ::=
             [ constraint_name_definition ] column_constraint [ constraint_attributes ]

constraint_name_definition ::= "CONSTRAINT" <space> constraint_name

constraint_name ::= qualified_name

column_constraint ::=
             "NOT" <space> "NULL"
     |       unique_specification
     |       references_specification
     |       check_constraint_definition

unique_specification ::= "UNIQUE" | "PRIMARY" <space> "KEY"

references_specification ::=
             "REFERENCES" <space> referenced_table_and_columns
             [ "MATCH" <space> match_type ]
             [ referential_triggered_action ]

referenced_table_and_columns ::= table_name <zspace> [ left_paren reference_column_list right_paren ]

table_name ::= qualified_name | qualified_local_table_name

reference_column_list ::= column_name_list

column_name_list ::= column_name [ { comma column_name }+ ]

match_type ::= "FULL" | "PARTIAL"

referential_triggered_action ::=
             update_rule [ delete_rule ]
     |       delete_rule [ update_rule ]

update_rule ::= "ON" <space> "UPDATE" <zspace> referential_action

referential_action ::=
                       "CASCADE"
                     | "SET" <space> "NULL"
                     | "SET" <space> "DEFAULT"
                     | "NO" <space> "ACTION"

delete_rule ::= "ON" <space> "DELETE" <zspace> referential_action

check_constraint_definition ::= "CHECK" <zspace> left_paren search_condition right_paren

search_condition ::=
             boolean_term
     |   search_condition <zspace> "OR" <zspace> boolean_term

boolean_term ::=
             boolean_factor
     |   boolean_term <zspace> "AND" <zspace> boolean_factor

boolean_factor ::= [ "NOT" <space> ] boolean_test

boolean_test ::= boolean_primary [ "IS" <space> [ "NOT" <space> ]
                                       truth_value ]

boolean_primary ::= predicate | left_paren search_condition right_paren

predicate ::=
             comparison_predicate
     |   between_predicate
     |   in_predicate
     |   like_predicate
     |   null_predicate
     |   quantified_comparison_predicate
     |   exists_predicate
     |   match_predicate
     |   overlaps_predicate

comparison_predicate ::= row_value_constructor comp_op row_value_constructor

row_value_constructor ::=
             row_value_constructor_element
     |   left_paren row_value_constructor_list right_paren
     |   row_subquery

row_value_constructor_element ::=
             value_expression
     |   null_specification
     |   default_specification

value_expression ::=
             numeric_value_expression
     |   string_value_expression
     |   datetime_value_expression
     |   interval_value_expression

numeric_value_expression ::=
             term
     |   numeric_value_expression plus_sign term
     |   numeric_value_expression minus_sign term

term ::=
             factor
     |   term asterisk factor
     |   term solidus factor

factor ::= [ sign <zspace> ] numeric_primary

numeric_primary ::= value_expression_primary | numeric_value_function

value_expression_primary ::=
             unsigned_value_specification
     |   column_reference
     |   set_function_specification
     |   scalar_subquery
     |   case_expression
     |   left_paren value_expression right_paren
     |   cast_specification

unsigned_value_specification ::= unsigned_literal | general_value_specification

unsigned_literal ::= unsigned_numeric_literal | general_literal

general_value_specification ::=
             parameter_specification
     |   dynamic_parameter_specification
     |   variable_specification
     |   "USER"
     |   "CURRENT_USER"
     |   "SESSION_USER"
     |   "SYSTEM_USER"
     |   "VALUE"

parameter_specification ::= parameter_name [ indicator_parameter ]

parameter_name ::= colon identifier

indicator_parameter ::= [ "INDICATOR" <space> ] parameter_name

dynamic_parameter_specification ::= question_mark

variable_specification ::= embedded_variable_name [ indicator_variable ]

embedded_variable_name ::= colon host_identifier

host_identifier ::=
             Ada_host_identifier
     |       C_host_identifier
     |       Cobol_host_identifier
     |       Fortran_host_identifier
     |       MUMPS_host_identifier
     |       Pascal_host_identifier
     |       PL_I_host_identifier

(*
Ada_host_identifier ::= !! See syntax rules

C_host_identifier ::= !! See syntax rules

Cobol_host_identifier ::= !! See syntax rules

Fortran_host_identifier ::= !! See syntax rules

MUMPS_host_identifier ::= !! See syntax rules

Pascal_host_identifier ::= !! See syntax rules

PL_I_host_identifier ::= !! See syntax rules
*)

Ada_host_identifier ::= do_not_care

C_host_identifier ::= do_not_care

Cobol_host_identifier ::= do_not_care

Fortran_host_identifier ::= do_not_care

MUMPS_host_identifier ::= do_not_care

Pascal_host_identifier ::= do_not_care

PL_I_host_identifier ::= do_not_care

indicator_variable ::= [ "INDICATOR" <space> ] embedded_variable_name

column_reference ::= [ qualifier period ] column_name

qualifier ::= table_name | correlation_name

correlation_name ::= identifier

set_function_specification ::=
             "COUNT" <zspace> left_paren asterisk right_paren
     |   general_set_function

general_set_function ::=
             set_function_type left_paren [ set_quantifier ] value_expression right_paren

set_function_type ::=
                    "AVG" | "MAX" | "MIN" | "SUM" | "COUNT"

set_quantifier ::=
                 "DISTINCT" | "ALL"

scalar_subquery ::= subquery

subquery ::= left_paren query_expression right_paren

query_expression ::= non_join_query_expression | joined_table

non_join_query_expression ::=
             non_join_query_term
     |       query_expression "UNION" [ <space> "ALL" ] <space> [ corresponding_spec ] query_term
     |       query_expression "EXCEPT" [ <space> "ALL" ] <space> [ corresponding_spec ] query_term

non_join_query_term ::=
             non_join_query_primary
     |       query_term "INTERSECT" [ <space> "ALL" ] <space> [ corresponding_spec ] query_primary

non_join_query_primary ::= simple_table | left_paren non_join_query_expression right_paren

simple_table ::=
             query_specification
     |       table_value_constructor
     |       explicit_table

query_specification ::=
             "SELECT" <space> [ set_quantifier ] select_list
             <space> table_expression

select_list ::=
             asterisk
     |       select_sublist [ { <zspace> comma <zspace> select_sublist }+ ]

select_sublist ::= derived_column | qualifier period asterisk

derived_column ::= value_expression [ <space> as_clause ]

as_clause ::= [ "AS" <space> ] column_name

table_expression ::=
             from_clause
             [ <space> where_clause ]
             [ <space> group_by_clause ]
             [ <space> having_clause ]

from_clause ::=
    "FROM" <space> table_reference
    [ { <zspace> comma <zspace> table_reference }+ ]

table_reference ::=
         table_name [ <space> correlation_specification ]
     |   derived_table <space> correlation_specification
     |   joined_table

correlation_specification ::=
             [ "AS" <space> ] correlation_name <zspace>
             [ left_paren derived_column_list right_paren ]

derived_column_list ::= column_name_list

derived_table ::= table_subquery

table_subquery ::= subquery

joined_table ::=
             cross_join
     |   qualified_join
     |   left_paren joined_table right_paren

cross_join ::=
             table_reference
             <space> "CROSS" <space> "JOIN" <zspace>
             table_reference

qualified_join ::=
             table_reference
             [ "NATURAL" <space> ]
             [ join_type ]
             "JOIN" <space>
             table_reference [ join_specification ]

join_type ::=
             "INNER" <zspace>
     |   outer_join_type [ "OUTER" <zspace> ]
     |   "UNION"

outer_join_type ::=
                  "LEFT" | "RIGHT" | "FULL"

join_specification ::= join_condition | named_columns_join

join_condition ::= "ON" <space> search_condition

named_columns_join ::= "USING" <zspace> left_paren join_column_list right_paren

join_column_list ::= column_name_list

where_clause ::= "WHERE" <space> search_condition

group_by_clause ::= "GROUP" <space> "BY" <zspace> grouping_column_reference_list

grouping_column_reference_list ::=
             grouping_column_reference [ { comma grouping_column_reference }+ ]

grouping_column_reference ::= column_reference [ collate_clause ]

collate_clause ::= "COLLATE" <space> collation_name

collation_name ::= qualified_name

having_clause ::= "HAVING" <space> search_condition

table_value_constructor ::= "VALUES" <zspace> table_value_constructor_list

table_value_constructor_list ::= row_value_constructor [ { comma row_value_constructor }+ ]

explicit_table ::= "TABLE" <space> table_name

query_term ::= non_join_query_term | joined_table

corresponding_spec ::= "CORRESPONDING" [ <space> "BY" <zspace> left_paren corresponding_column_list right_paren ]

corresponding_column_list ::= column_name_list

query_primary ::= non_join_query_primary | joined_table

case_expression ::= case_abbreviation | case_specification

case_abbreviation ::=
             "NULLIF" <zspace> left_paren value_expression comma value_expression right_paren
     |       "COALESCE" <zspace> left_paren value_expression { comma value_expression }+  right_paren

case_specification ::= simple_case | searched_case

simple_case ::=
             "CASE" <zspace> case_operand
                     simple_when_clause+
                     [ else_clause ]
             <zspace> "END"

case_operand ::= value_expression

simple_when_clause ::= "WHEN" <zspace> when_operand
                         <space> "THEN" <zspace> result

when_operand ::= value_expression

result ::= result_expression | "NULL"

result_expression ::= value_expression

else_clause ::= "ELSE" <space> result

searched_case ::=
             "CASE" <space>
             searched_when_clause+
             [ else_clause ]
             <space> "END"

searched_when_clause ::= "WHEN" <space> search_condition
                           <space> "THEN" <zspace> result

cast_specification ::= "CAST" <space> left_paren cast_operand
                         <space> "AS" <space> cast_target right_paren

cast_operand ::= value_expression | "NULL"

cast_target ::= domain_name | data_type

numeric_value_function ::= position_expression | extract_expression |  length_expression

position_expression ::=
     "POSITION" <space> left_paren character_value_expression
     <space> "IN" <space> character_value_expression right_paren

character_value_expression ::= concatenation | character_factor

concatenation ::= character_value_expression concatenation_operator character_factor

character_factor ::= character_primary [ collate_clause ]

character_primary ::= value_expression_primary | string_value_function

string_value_function ::= character_value_function | bit_value_function

character_value_function ::=
             character_substring_function
     |   fold
     |   form_of_use_conversion
     |   character_translation
     |   trim_function

character_substring_function ::=
             "SUBSTRING" <zspace>
             left_paren character_value_expression
             <space> "FROM" <space> start_position
             [ <space> "FOR" <space> string_length ] right_paren

start_position ::= numeric_value_expression

string_length ::= numeric_value_expression

fold ::= { "UPPER" | "LOWER" } <zspace>
           left_paren character_value_expression right_paren

form_of_use_conversion ::=
             "CONVERT" <zspace>
             left_paren character_value_expression
             <space> "USING" <space>
             form_of_use_conversion_name right_paren

form_of_use_conversion_name ::= qualified_name

character_translation ::=
    "TRANSLATE" <zspace>
    left_paren character_value_expression
    <space> "USING" <space> translation_name right_paren

translation_name ::= qualified_name

trim_function ::= "TRIM" <zspace>
                    left_paren trim_operands right_paren

trim_operands ::=
    [ [ trim_specification ]
      [ trim_character ] <space> "FROM" <space> ] trim_source

trim_specification ::=
    "LEADING" | "TRAILING" | "BOTH"

trim_character ::= character_value_expression

trim_source ::= character_value_expression

bit_value_function ::= bit_substring_function

bit_substring_function ::=
    "SUBSTRING" <zspace>
    left_paren bit_value_expression
    <space> "FROM" <space>
    start_position
    [ <space> "FOR" <space> string_length ] right_paren

bit_value_expression ::= bit_concatenation | bit_factor

bit_concatenation ::= bit_value_expression concatenation_operator bit_factor

bit_factor ::= bit_primary

bit_primary ::= value_expression_primary | string_value_function

extract_expression ::=
    "EXTRACT" <zspace>
    left_paren extract_field
    <space> "FROM" <space> extract_source right_paren

extract_field ::= datetime_field | time_zone_field

datetime_field ::= non_second_datetime_field | "SECOND"

time_zone_field ::= "TIMEZONE_HOUR" | "TIMEZONE_MINUTE"

extract_source ::= datetime_value_expression | interval_value_expression

datetime_value_expression ::=
             datetime_term
     |       interval_value_expression plus_sign datetime_term
     |       datetime_value_expression plus_sign interval_term
     |       datetime_value_expression minus_sign interval_term

interval_term ::=
             interval_factor
     |       interval_term_2 asterisk factor
     |       interval_term_2 solidus factor
     |       term asterisk interval_factor

interval_factor ::= [ sign ] interval_primary

interval_primary ::= value_expression_primary [ interval_qualifier ]

interval_term_2 ::= interval_term

interval_value_expression ::=
             interval_term
     |       interval_value_expression_1 plus_sign interval_term_1
     |       interval_value_expression_1 minus_sign interval_term_1
     |       left_paren datetime_value_expression minus_sign datetime_term right_paren interval_qualifier

interval_value_expression_1 ::= interval_value_expression

interval_term_1 ::= interval_term

datetime_term ::= datetime_factor

datetime_factor ::= datetime_primary [ time_zone ]

datetime_primary ::= value_expression_primary | datetime_value_function

time_zone ::= "AT" <space> time_zone_specifier

time_zone_specifier ::=
      "LOCAL"
    | "TIME" <space> "ZONE" <space> interval_value_expression

length_expression ::= char_length_expression | octet_length_expression | bit_length_expression

char_length_expression ::=
    { "CHAR_LENGTH" | "CHARACTER_LENGTH" } <zspace>
    left_paren string_value_expression right_paren

string_value_expression ::= character_value_expression | bit_value_expression

octet_length_expression ::=
    "OCTET_LENGTH" <zspace>
    left_paren string_value_expression right_paren

bit_length_expression ::=
    "BIT_LENGTH" <zspace>
    left_paren string_value_expression right_paren

null_specification ::= "NULL"

default_specification ::= "DEFAULT"

row_value_constructor_list ::= row_value_constructor_element [ { comma row_value_constructor_element } + ]

row_subquery ::= subquery

comp_op ::=
             equals_operator
     |   not_equals_operator
     |   less_than_operator
     |   greater_than_operator
     |   less_than_or_equals_operator
     |   greater_than_or_equals_operator

between_predicate ::=
    row_value_constructor
    <zspace> [ "NOT" <space> ]
    "BETWEEN" <space>
    row_value_constructor <space> "AND" <space> row_value_constructor

in_predicate ::=
    row_value_constructor
    <zspace> [ "NOT" <space> ] "IN" <space> in_predicate_value

in_predicate_value ::= table_subquery | left_paren in_value_list right_paren

in_value_list ::= value_expression { comma value_expression } +

like_predicate ::=
    match_value
    <zspace> [ "NOT" <space> ] "LIKE" <space>
    pattern [ <space> "ESCAPE" <zspace> escape_character ]

match_value ::= character_value_expression

pattern ::= character_value_expression

escape_character ::= character_value_expression

null_predicate ::= "IS" <space> [ "NOT" <space> ] "NULL"

quantified_comparison_predicate ::= row_value_constructor comp_op quantifier table_subquery

quantifier ::= all | some

all ::= "ALL"

some ::= "SOME" | "ANY"

exists_predicate ::= "EXISTS" <space> table_subquery

unique_predicate ::= "UNIQUE" <space> table_subquery

match_predicate ::=
    row_value_constructor
    <zspace> "MATCH" <space>
    [ "UNIQUE" <space> ]
    [ "PARTIAL" | "FULL" ] <zspace>
    table_subquery

overlaps_predicate ::=
    row_value_constructor_1
    <space> "OVERLAPS" <space> row_value_constructor_2

row_value_constructor_1 ::= row_value_constructor

row_value_constructor_2 ::= row_value_constructor

truth_value ::=
    "TRUE" | "FALSE" | "UNKNOWN"


constraint_attributes ::=
     constraint_check_time
     [ <space> [ "NOT" <space> ] "DEFERRABLE" <zspace> ]
  |  <space> [ "NOT" <space> ] "DEFERRABLE" <zspace>
     [ constraint_check_time ]

constraint_check_time ::=
    "INITIALLY" <space> "DEFERRED"
  | "INITIALLY" <space> "IMMEDIATE"

table_constraint_definition ::= [ constraint_name_definition ] table_constraint [ constraint_check_time ]

table_constraint ::=
             unique_constraint_definition
     |       referential_constraint_definition
     |       check_constraint_definition

unique_constraint_definition ::= unique_specification left_paren unique_column_list right_paren

unique_column_list ::= column_name_list

referential_constraint_definition ::=
    "FOREIGN" <space> "KEY" <zspace>
    left_paren referencing_columns right_paren
    references_specification

referencing_columns ::= reference_column_list

module_contents ::=
             declare_cursor
     |       dynamic_declare_cursor
     |       procedure

declare_cursor ::=
    "DECLARE" <space> cursor_name
    [ <space> "INSENSITIVE" ]
    [ <space> "SCROLL" ]
    <space> "CURSOR" <space> "FOR" <zspace>
    cursor_specification

cursor_name ::= identifier

cursor_specification ::= query_expression [ order_by_clause ] [ updatability_clause ]

order_by_clause ::=
    "ORDER" <space> "BY" <space> sort_specification_list

sort_specification_list ::= sort_specification [ { comma sort_specification }+ ]

sort_specification ::= sort_key [ collate_clause ] [ ordering_specification ]

sort_key ::= column_name | unsigned_integer

ordering_specification ::= "ASC" | "DESC"

updatability_clause ::=
    "FOR" <space>
    { "READ" <space> "ONLY"
    | "UPDATE" [ <space> "OF" <zspace> column_name_list ] }

dynamic_declare_cursor ::=
    "DECLARE" <space> cursor_name <space>
    [ "INSENSITIVE" <space> ]
    [ "SCROLL" <space> ]
    "CURSOR" <space> "FOR" <zspace> statement_name

statement_name ::= identifier

procedure ::=
    "PROCEDURE" <space> procedure_name
    parameter_declaration_list semicolon
    SQL_procedure_statement semicolon

procedure_name ::= identifier

parameter_declaration_list ::=
             left_paren parameter_declaration [ { comma parameter_declaration }+ ] right_paren

parameter_declaration ::= parameter_name data_type | status_parameter

status_parameter ::= "SQLCODE" | "SQLSTATE"

SQL_procedure_statement ::=
             SQL_schema_statement
     |       SQL_data_statement
     |       SQL_transaction_statement
     |       SQL_connection_statement
     |       SQL_session_statement
     |       SQL_dynamic_statement
     |       SQL_diagnostics_statement

SQL_schema_statement ::=
             SQL_schema_definition_statement
     |       SQL_schema_manipulation_statement

SQL_schema_definition_statement ::=
             schema_definition
     |       table_definition
     |       view_definition
     |       grant_statement
     |       domain_definition
     |       character_set_definition
     |       collation_definition
     |       translation_definition
     |       assertion_definition

schema_definition ::=
    "CREATE" <space> "SCHEMA" <space> schema_name_clause
    [ schema_character_set_specification ]
    [ schema_element+ ]

schema_name_clause ::=
     schema_name
   | "AUTHORIZATION" <zspace> schema_authorization_identifier
   | schema_name <space>
     "AUTHORIZATION" <zspace> schema_authorization_identifier

schema_authorization_identifier ::= authorization_identifier

schema_character_set_specification ::=
    "DEFAULT" <space> "CHARACTER" <space> "SET"
    <space> character_set_specification

schema_element ::=
             domain_definition
     |       table_definition
     |       view_definition
     |       grant_statement
     |       assertion_definition
     |       character_set_definition
     |       collation_definition
     |       translation_definition

domain_definition ::=
     "CREATE" <space> "DOMAIN" <space> domain_name <zspace>
     [ "AS" <space> ] data_type
     [ default_clause ] [ domain_constraint ] [ collate_clause ]

domain_constraint ::=
             [ constraint_name_definition ] check_constraint_definition [ constraint_attributes ]

table_definition ::=
    "CREATE" <space>
    [ { "GLOBAL" | "LOCAL" } <space> "TEMPORARY" <space> ]
    "TABLE" <space> table_name
    table_element_list
    [ "ON" <space> "COMMIT" <space>
      { "DELETE" <space> | "PRESERVE" <space> } "ROWS" ]

view_definition ::=
    "CREATE" <space> "VIEW" <space> table_name <zspace>
    [ left_paren view_column_list right_paren <zspace> ]
    "AS" <space> query_expression
    [ "WITH" <space> [ levels_clause ]
      "CHECK" <space> "OPTION" ]

view_column_list ::= column_name_list

levels_clause ::= "CASCADED" | "LOCAL"

grant_statement ::=
    "GRANT" <space> privileges <space>
    "ON" <space> object_name <space>
    "TO" <space> grantee
    [ { comma grantee }+ ]
    [ <space> "WITH" <space> "GRANT" <space> "OPTION" ]

privileges ::=
    "ALL" <space> "PRIVILEGES" | action_list

action_list ::= action [ { comma action }+ ]

action ::=
    "SELECT"
  | "DELETE"
  | "INSERT" <zspace> [ left_paren privilege_column_list right_paren ]
  | "UPDATE" <zspace> [ left_paren privilege_column_list right_paren ]
  | "REFERENCES" <zspace> [ left_paren privilege_column_list right_paren ]
  | "USAGE"

privilege_column_list ::= column_name_list

object_name ::=
    [ "TABLE" <space> ] table_name
  | "DOMAIN" <space> domain_name
  | "COLLATION" <space> collation_name
  | "CHARACTER" <space> "SET" <space> character_set_name
  | "TRANSLATION" <space> translation_name

grantee ::= "PUBLIC" | authorization_identifier

assertion_definition ::=
    "CREATE" <space> "ASSERTION" <space>
    constraint_name assertion_check [ constraint_attributes ]

assertion_check ::=
    "CHECK" <zspace> left_paren search_condition right_paren

character_set_definition ::=
    "CREATE" <space> "CHARACTER" <space> "SET" <space> character_set_name
    <space> [ "AS" <space> ] character_set_source
    [ collate_clause | limited_collation_definition ]

character_set_source ::= "GET" <space> existing_character_set_name

existing_character_set_name ::=
             standard_character_repertoire_name
     |       implementation_defined_character_repertoire_name
     |       schema_character_set_name

schema_character_set_name ::= character_set_name

limited_collation_definition ::=
    "COLLATION" <space> "FROM" <space> collation_source

collation_source ::= collating_sequence_definition | translation_collation

collating_sequence_definition ::=
     external_collation
   | schema_collation_name
   | "DESC" <zspace> left_paren collation_name right_paren
   | "DEFAULT"

external_collation ::=
    "EXTERNAL" <zspace>
    left_paren quote external_collation_name quote right_paren

external_collation_name ::= standard_collation_name | implementation_defined_collation_name

standard_collation_name ::= collation_name

implementation_defined_collation_name ::= collation_name

schema_collation_name ::= collation_name

translation_collation ::=
    "TRANSLATION" <space> translation_name
    [ <space> "THEN" <space> "COLLATION" <space> collation_name ]

collation_definition ::=
    "CREATE" <space> "COLLATION" <space> collation_name
    <space> "FOR" <space> character_set_specification
    <space> "FROM" <space> collation_source [ pad_attribute ]

pad_attribute ::= #"NO\s+PAD|PAD\s+SPACE"

translation_definition ::=
    "CREATE" <space> "TRANSLATION" <space> translation_name
    <space> "FOR" <space> source_character_set_specification
    <space> "TO" <space> target_character_set_specification
    <space> "FROM" <space> translation_source

source_character_set_specification ::= character_set_specification

target_character_set_specification ::= character_set_specification

translation_source ::= translation_specification

translation_specification ::=
             external_translation
     |       "IDENTITY"
     |       schema_translation_name

external_translation ::=
    "EXTERNAL" <space>
    left_paren quote external_translation_name quote right_paren

external_translation_name ::=
             standard_translation_name
     |       implementation_defined_translation_name

standard_translation_name ::= translation_name

implementation_defined_translation_name ::= translation_name

schema_translation_name ::= translation_name

SQL_schema_manipulation_statement ::=
             drop_schema_statement
     |       alter_table_statement
     |       drop_table_statement
     |       drop_view_statement
     |       revoke_statement
     |       alter_domain_statement
     |       drop_domain_statement
     |       drop_character_set_statement
     |       drop_collation_statement
     |       drop_translation_statement
     |       drop_assertion_statement

drop_schema_statement ::=
    "DROP" <space> "SCHEMA" <space> schema_name drop_behaviour

drop_behaviour ::= "CASCADE" | "RESTRICT"

alter_table_statement ::=
    "ALTER" <space> "TABLE" <space> table_name alter_table_action

alter_table_action ::=
             add_column_definition
     |       alter_column_definition
     |       drop_column_definition
     |       add_table_constraint_definition
     |       drop_table_constraint_definition

add_column_definition ::=
     "ADD" <space> [ "COLUMN" <space> ] column_definition

alter_column_definition ::=
    "ALTER" <space> [ "COLUMN" <space> ] column_name alter_column_action

alter_column_action ::= set_column_default_clause | drop_column_default_clause

set_column_default_clause ::= "SET" <space> default_clause

drop_column_default_clause ::= "DROP" <space> "DEFAULT"

drop_column_definition ::=
    "DROP" <space> [ "COLUMN" <space> ] column_name drop_behaviour

add_table_constraint_definition ::=
    "ADD" <space> table_constraint_definition

drop_table_constraint_definition ::=
    "DROP" <space> "CONSTRAINT" <space> constraint_name drop_behaviour

drop_table_statement ::=
    "DROP" <space> "TABLE" <space> table_name drop_behaviour

drop_view_statement ::=
    "DROP" <space> "VIEW" <space> table_name drop_behaviour

revoke_statement ::=
    "REVOKE" <space>
    [ "GRANT" <space> "OPTION" <space> "FOR" <space> ]
    privileges <space> "ON" <space> object_name
    <space> "FROM" <space> grantee
    [ { comma grantee }+ ] drop_behaviour

alter_domain_statement ::=
    "ALTER" <space> "DOMAIN" <space> domain_name alter_domain_action

alter_domain_action ::=
             set_domain_default_clause
     |       drop_domain_default_clause
     |       add_domain_constraint_definition
     |       drop_domain_constraint_definition

set_domain_default_clause ::= "SET" <space> default_clause

drop_domain_default_clause ::= "DROP" <space> "DEFAULT"

add_domain_constraint_definition ::= "ADD" <space> domain_constraint

drop_domain_constraint_definition ::=
    "DROP" <space> "CONSTRAINT" <space> constraint_name

drop_domain_statement ::=
    "DROP" <space> "DOMAIN" <space> domain_name drop_behaviour

drop_character_set_statement ::=
    "DROP" <space> "CHARACTER" <space> "SET" <space> character_set_name

drop_collation_statement ::=
    "DROP" <space> "COLLATION" <space> collation_name

drop_translation_statement ::=
    "DROP" <space> "TRANSLATION" <space> translation_name

drop_assertion_statement ::=
    "DROP" <space> "ASSERTION" <space> constraint_name

SQL_data_statement ::=
             open_statement
     |       fetch_statement
     |       close_statement
     |       select_statement_single_row
     |       SQL_data_change_statement

open_statement ::= "OPEN" <space> cursor_name

fetch_statement ::=
    "FETCH" [ <space> [ fetch_orientation <space> ] "FROM" ]
    <space> cursor_name <space> "INTO" <space> fetch_target_list

fetch_orientation ::=
     "NEXT"
   | "PRIOR"
   | "FIRST"
   | "LAST"
   | { "ABSOLUTE" <space> | "RELATIVE" <space> } simple_value_specification

simple_value_specification ::=
    parameter_name
  | embedded_variable_name
  | literal

fetch_target_list ::= target_specification [ { comma target_specification }+ ]

target_specification ::=
             parameter_specification
     |       variable_specification

close_statement ::= "CLOSE" <space> cursor_name

select_statement_single_row ::=
    "SELECT" <space> [ set_quantifier ] select_list
    <space> "INTO" <space> select_target_list table_expression

select_target_list ::= target_specification [ { comma target_specification }+ ]

SQL_data_change_statement ::=
             delete_statement_positioned
     |       delete_statement_searched
     |       insert_statement
     |       update_statement_positioned
     |       update_statement_searched

delete_statement_positioned ::=
    "DELETE" <space> "FROM" <space> table_name
    "WHERE" <space> "CURRENT" <space> "OF" <space> cursor_name

delete_statement_searched ::=
    "DELETE" <space> "FROM" <space> table_name
    [ <space> "WHERE" <space> search_condition ]

insert_statement ::=
    "INSERT" <space> "INTO" table_name insert_columns_and_source

insert_columns_and_source ::=
     [ left_paren insert_column_list right_paren ] query_expression
   | "DEFAULT" <space> "VALUES"

insert_column_list ::= column_name_list

update_statement_positioned ::=
     "UPDATE" <space> table_name <space> "SET" <space> set_clause_list
     <space> "WHERE" <space> "CURRENT" <space> "OF" <space> cursor_name

set_clause_list ::= set_clause [ { comma set_clause } + ]

set_clause ::= object_column equals_operator update_source

object_column ::= column_name

update_source ::= value_expression | null_specification | "DEFAULT"

update_statement_searched ::=
    "UPDATE" <space> table_name <space> "SET" <space> set_clause_list
    [ <space> "WHERE" <space> search_condition ]

SQL_transaction_statement ::=
             set_transaction_statement
     |       set_constraints_mode_statement
     |       commit_statement
     |       rollback_statement

set_transaction_statement ::=
     "SET" <space> "TRANSACTION" <space> transaction_mode
     [ { comma transaction_mode }+ ]

transaction_mode ::=
             isolation_level
     |       transaction_access_mode
     |       diagnostics_size

isolation_level ::=
    "ISOLATION" <space> "LEVEL" <space> level_of_isolation

level_of_isolation ::=
             "READ" <space> "UNCOMMITTED"
     |       "READ" <space> "COMMITTED"
     |       "REPEATABLE" <space> "READ"
     |       "SERIALIZABLE"

transaction_access_mode ::=
    "READ" <space> "ONLY" | "READ" <space> "WRITE"

diagnostics_size ::=
    "DIAGNOSTICS" <space> "SIZE" <space> number_of_conditions

number_of_conditions ::= simple_value_specification

set_constraints_mode_statement ::=
     "SET" <space> "CONSTRAINTS" <space> constraint_name_list
     { <space> "DEFERRED" | <space> "IMMEDIATE" }

constraint_name_list ::=
    "ALL" | constraint_name [ { comma constraint_name }+ ]

commit_statement ::= "COMMIT" [ <space> "WORK" ]

rollback_statement ::= "ROLLBACK" [ <space> "WORK" ]

SQL_connection_statement ::=
             connect_statement
     |       set_connection_statement
     |       disconnect_statement

connect_statement ::=
     "CONNECT" <space> "TO" <space> connection_target

connection_target ::=
     SQL_server_name
     [ <space> "AS" <space> connection_name ]
     [ <space> "USER" <space> user_name ]
   | "DEFAULT"

SQL_server_name ::= simple_value_specification

connection_name ::= simple_value_specification

user_name ::= simple_value_specification

set_connection_statement ::=
     "SET" <space> "CONNECTION" <space> connection_object

connection_object ::= "DEFAULT" | connection_name

disconnect_statement ::= "DISCONNECT" <space> disconnect_object

disconnect_object ::= connection_object | "ALL" | "CURRENT"

SQL_session_statement ::=
             set_catalog_statement
     |       set_schema_statement
     |       set_names_statement
     |       set_session_authorization_identifier_statement
     |       set_local_time_zone_statement

set_catalog_statement ::=
     "SET" <space> "CATALOG" <space> value_specification

value_specification ::= literal | general_value_specification

set_schema_statement ::=
    "SET" <space> "SCHEMA" <space> value_specification

set_names_statement ::=
    "SET" <space> "NAMES" <space> value_specification

set_session_authorization_identifier_statement ::=
    "SET" <space> "SESSION" <space> "AUTHORIZATION" <space>
    value_specification

set_local_time_zone_statement ::=
    "SET" <space> "TIME" <space> "ZONE" <space> set_time_zone_value

set_time_zone_value ::= interval_value_expression | "LOCAL"

SQL_dynamic_statement ::=
             system_descriptor_statement
     |       prepare_statement
     |       deallocate_prepared_statement
     |       describe_statement
     |       execute_statement
     |       execute_immediate_statement
     |       SQL_dynamic_data_statement

system_descriptor_statement ::=
             allocate_descriptor_statement
     |       deallocate_descriptor_statement
     |       get_descriptor_statement
     |       set_descriptor_statement

allocate_descriptor_statement ::=
     "ALLOCATE" <space> "DESCRIPTOR" <space> descriptor_name
     [ <space> "WITH" <space> "MAX" <space> occurrences ]

descriptor_name ::= [ scope_option ] simple_value_specification

scope_option ::= "GLOBAL" | "LOCAL"

occurrences ::= simple_value_specification

deallocate_descriptor_statement ::=
    "DEALLOCATE" <space> "DESCRIPTOR" <space> descriptor_name

set_descriptor_statement ::=
     "SET" <space> "DESCRIPTOR" <space> descriptor_name
     set_descriptor_information

set_descriptor_information ::=
     set_count
   | "VALUE" <space> item_number set_item_information
     [ { comma set_item_information }+ ]

set_count ::=
     "COUNT" <space> equals_operator simple_value_specification_1

simple_value_specification_1 ::= simple_value_specification

item_number ::= simple_value_specification

set_item_information ::= descriptor_item_name equals_operator simple_value_specification_2

descriptor_item_name ::=
     "TYPE"
   | "LENGTH"
   | "OCTET_LENGTH"
   | "RETURNED_LENGTH"
   | "RETURNED_OCTET_LENGTH"
   | "PRECISION"
   | "SCALE"
   | "DATETIME_INTERVAL_CODE"
   | "DATETIME_INTERVAL_PRECISION"
   | "NULLABLE"
   | "INDICATOR"
   | "DATA"
   | "NAME"
   | "UNNAMED"
   | "COLLATION_CATALOG"
   | "COLLATION_SCHEMA"
   | "COLLATION_NAME"
   | "CHARACTER_SET_CATALOG"
   | "CHARACTER_SET_SCHEMA"
   | "CHARACTER_SET_NAME"

simple_value_specification_2 ::= simple_value_specification

get_descriptor_statement ::=
    "GET" <space> "DESCRIPTOR" <space> descriptor_name
    get_descriptor_information

get_descriptor_information ::=
     get_count
   | "VALUE" <space> item_number get_item_information
     [ { comma get_item_information }+ ]

get_count ::=
    simple_target_specification_1 equals_operator <space> "COUNT"

simple_target_specification_1 ::= simple_target_specification

simple_target_specification ::= parameter_name | embedded_variable_name

get_item_information ::= simple_target_specification_2 equals_operator descriptor_item_name

simple_target_specification_2 ::= simple_target_specification

prepare_statement ::=
    "PREPARE" <space> SQL_statement_name
    <space> "FROM" <space> SQL_statement_variable

SQL_statement_name ::= statement_name | extended_statement_name

extended_statement_name ::= [ scope_option ] simple_value_specification

SQL_statement_variable ::= simple_value_specification

deallocate_prepared_statement ::=
    "DEALLOCATE" <space> "PREPARE" <space> SQL_statement_name

describe_statement ::= describe_input_statement | describe_output_statement

describe_input_statement ::=
    "DESCRIBE" <space> "INPUT" <space> SQL_statement_name
    using_descriptor

using_descriptor ::=
    { "USING" <space> | "INTO" <space> }
    "SQL" <space> "DESCRIPTOR" <space> descriptor_name

describe_output_statement ::=
    "DESCRIBE" [ <space> "OUTPUT" ]
    <space> SQL_statement_name using_descriptor

execute_statement ::=
    "EXECUTE" <space> SQL_statement_name
    [ result_using_clause ] [ parameter_using_clause ]

result_using_clause ::= using_clause

using_clause ::= using_arguments | using_descriptor

using_arguments ::=
    { "USING" <space> | "INTO" <space> }
    argument [ { comma argument }+ ]

argument ::= target_specification

parameter_using_clause ::= using_clause

execute_immediate_statement ::=
    "EXECUTE" <space> "IMMEDIATE" <space> SQL_statement_variable

SQL_dynamic_data_statement ::=
             allocate_cursor_statement
     |       dynamic_open_statement
     |       dynamic_close_statement
     |       dynamic_fetch_statement
     |       dynamic_delete_statement_positioned
     |       dynamic_update_statement_positioned

allocate_cursor_statement ::=
     "ALLOCATE" <space> extended_cursor_name
     [ <space> "INSENSITIVE" ]
     [ <space> "SCROLL" ]
     <space> "CURSOR" <space> "FOR" <space> extended_statement_name

extended_cursor_name ::= [ scope_option ] simple_value_specification

dynamic_open_statement ::=
    "OPEN" <space> dynamic_cursor_name [ using_clause ]

dynamic_cursor_name ::= cursor_name | extended_cursor_name

dynamic_close_statement ::=
    "CLOSE" <space> dynamic_cursor_name

dynamic_fetch_statement ::=
    "FETCH" <space>
    [ [ fetch_orientation <space> ] "FROM" <space> ]
    dynamic_cursor_name

dynamic_delete_statement_positioned ::=
    "DELETE" <space> "FROM" <space> table_name
    <space> "WHERE" <space> "CURRENT" <space> "OF" <space>
    dynamic_cursor_name

dynamic_update_statement_positioned ::=
    "UPDATE" <space> table_name <space>
    "SET" <space> set_clause [ { comma set_clause }+ ]
    "WHERE" <space> "CURRENT" <space> "OF" <space> dynamic_cursor_name

SQL_diagnostics_statement ::= get_diagnostics_statement

get_diagnostics_statement ::=
    "GET" <space> "DIAGNOSTICS" <space> sql_diagnostics_information

sql_diagnostics_information ::= statement_information | condition_information

statement_information ::=
    statement_information_item
    [ { comma statement_information_item }+ ]

statement_information_item ::=
    simple_target_specification
    equals_operator statement_information_item_name

statement_information_item_name ::=
    "NUMBER" | "MORE" | "COMMAND_FUNCTION" | "DYNAMIC_FUNCTION" | "ROW_COUNT"

condition_information ::=
    "EXCEPTION" <space> condition_number
    condition_information_item
    [ { comma condition_information_item }+ ]

condition_number ::= simple_value_specification

condition_information_item ::=
    simple_target_specification
    equals_operator
    condition_information_item_name

condition_information_item_name ::=
     "CONDITION_NUMBER"
   | "RETURNED_SQLSTATE"
   | "CLASS_ORIGIN"
   | "SUBCLASS_ORIGIN"
   | "SERVER_NAME"
   | "CONNECTION_NAME"
   | "CONSTRATIN_CATALOG"
   | "CONSTRAINT_SCHEMA"
   | "CONSTRAINT_NAME"
   | "CATALOG_NAME"
   | "SCHEMA_NAME"
   | "TABLE_NAME"
   | "COLUMN_NAME"
   | "CURSOR_NAME"
   | "MESSAGE_TEXT"
   | "MESSAGE_LENGTH"
   | "MESSAGE_OCTET_LENGTH"

(*
embedded_SQL_host_program ::=
             embedded_SQL_Ada_program
     |       embedded_SQL_C_program
     |       embedded_SQL_Cobol_program
     |       embedded_SQL_Fortran_program
     |       embedded_SQL_MUMPS_program
     |       embedded_SQL_Pascal_program
     |       embedded_SQL_PL_I_program

embedded_SQL_Ada_program ::= !! See the syntax rules

embedded_SQL_C_program ::= !! See the syntax rules

embedded_SQL_Cobol_program ::= !! See the syntax rules

embedded_SQL_Fortran_program ::= !! See the syntax rules

embedded_SQL_MUMPS_program ::= !! See the syntax rules

embedded_SQL_Pascal_program ::= !! See the syntax rules

embedded_SQL_PL_I_program ::= !! See the syntax rules
*)

embedded_SQL_declare_section ::=
             embedded_SQL_begin_declare
                     [ embedded_character_set_declaration ]
                     [ host_variable_definition + ]
                     embedded_SQL_end_declare
     |       embedded_SQL_MUMPS_declare

embedded_SQL_begin_declare ::=
    SQL_prefix <space>
    "BEGIN" <space> "DECLARE" <space> "SECTION"
    [ <space> SQL_terminator ]

SQL_prefix ::=
    "EXEC" <space> "SQL"
  | ampersand "SQL" left_paren

SQL_terminator ::=
    "END-EXEC" | semicolon | right_paren

embedded_character_set_declaration ::=
    "SQL" <space> "NAMES" <space> "ARE" <space> character_set_specification

host_variable_definition ::= do_not_care

embedded_SQL_end_declare ::=
    SQL_prefix <space>
    "END" <space> "DECLARE" <space> "SECTION"
    [ <space> SQL_terminator ]

embedded_SQL_MUMPS_declare ::=
    SQL_prefix <space>
    "BEGIN" <space> "DECLARE" <space> "SECTION" <space>
    [ embedded_character_set_declaration ]
    [ host_variable_definition+ ]
    "END" <space> "DECLARE" <space> "SECTION" <space>
    SQL_terminator

(*
host_variable_definition ::=
             Ada_variable_definition
     |       C_variable_definition
     |       Cobol_variable_definition
     |       Fortran_variable_definition
     |       MUMPS_variable_definition
     |       Pascal_variable_definition
     |       PL_I_variable_definition


Ada_variable_definition ::=
             Ada_host_identifier [ { comma Ada_host_identifier }+ ] colon
             Ada_type_specification [ Ada_initial_value ]

Ada_type_specification ::= Ada_qualified_type_specification | Ada_unqualified_type_specification

Ada_qualified_type_specification ::=
             SQL_STANDARD.CHAR [ CHARACTER SET [ IS ] character_set_specification ] left_paren 1 double_period length right_paren
     |       SQL_STANDARD.BIT left_paren 1 double_period length right_paren
     |       SQL_STANDARD.SMALLINT
     |       SQL_STANDARD.INT
     |       SQL_STANDARD.REAL
     |       SQL_STANDARD.DOUBLE_PRECISION
     |       SQL_STANDARD.SQLCODE_TYPE
     |       SQL_STANDARD.SQLSTATE_TYPE
     |       SQL_STANDARD.INDICATOR_TYPE

Ada_unqualified_type_specification ::=
             CHAR left_paren 1 double_period length right_paren
     |       BIT left_paren 1 double_period length right_paren
     |       SMALLINT
     |       INT
     |       REAL
     |       DOUBLE_PRECISION
     |       SQLCODE_TYPE
     |       SQLSTATE_TYPE
     |       INDICATOR_TYPE

Ada_initial_value ::= Ada_assignment_operator character_representation

Ada_assignment_operator ::= colonequals_operator

C_variable_definition ::= [ C_storage_class ] [ C_class_modifier ] C_variable_specification semicolon

C_storage_class ::= auto | extern | static

C_class_modifier ::= const | volatile

C_variable_specification ::=
             C_numeric_variable
     |       C_character_variable
     |       C_derived_variable

C_numeric_variable ::=
             { long | short | float | double }
                     C_host_identifier [ C_initial_value ]
                     [ { comma C_host_identifier [ C_initial_value ] }+ ]

C_initial_value ::= equals_operator character_representation

C_character_variable ::=
             char [ CHARACTER SET [ IS ] character_set_specification ]
                     C_host_identifier C_array_specification [ C_initial_value ]
                     [ { comma C_host_identifier C_array_specification [ C_initial_value ] }+ ]

C_array_specification ::= left_bracket length right_bracket

C_derived_variable ::= C_VARCHAR_variable | C_bit_variable

C_VARCHAR_variable ::=
             VARCHAR [ CHARACTER SET [ IS ] character_set_specification ]
                     C_host_identifier C_array_specification [ C_initial_value ]
                     [ { comma C_host_identifier C_array_specification [ C_initial_value ] }+ ]

C_bit_variable ::=
             BIT C_host_identifier C_array_specification [ C_initial_value ]
                     [ { comma C_host_identifier C_array_specification [ C_initial_value ] }+ ]

Cobol_variable_definition ::=
     +omitted+

Fortran_variable_definition ::=
     +omitted+

MUMPS_variable_definition ::=
     +omitted+

Pascal_variable_definition ::=
     +omitted+

PL_I_variable_definition ::=
     +omitted+

embedded_SQL_end_declare ::= SQL_prefix END DECLARE SECTION [ SQL_terminator ]

embedded_SQL_MUMPS_declare ::=
     SQL_prefix
     BEGIN DECLARE SECTION
             [ embedded_character_set_declaration ]
             [ host_variable_definition+ ]
     END DECLARE SECTION
     SQL_terminator
*)
embedded_SQL_statement ::=
    SQL_prefix statement_or_declaration [ SQL_terminator ]

statement_or_declaration ::=
             declare_cursor
     |       dynamic_declare_cursor
     |       temporary_table_declaration
     |       embedded_exception_declaration
     |       SQL_procedure_statement

embedded_exception_declaration ::=
    "WHENEVER" <space> condition condition_action

condition ::= "SQLERROR" | "NOT" <space> "FOUND"

condition_action ::= "CONTINUE" | go_to

go_to ::= { "GOTO" | "GO" <space> "TO" } <space> goto_target

goto_target ::=
             host_label_identifier
     |       unsigned_integer
     |       host_PL_I_label_variable

do_not_care ::= #"\w+"

(*
host_label_identifier ::= !! See the syntax rules
*)

host_label_identifier ::= do_not_care

(*
host_PL_I_label_variable ::= !! See the syntax rules
*)
host_PL_I_label_variable ::= do_not_care

preparable_statement ::=
             preparable_SQL_data_statement
     |       preparable_SQL_schema_statement
     |       preparable_SQL_transaction_statement
     |       preparable_SQL_session_statement
     |       preparable_SQL_implementation_defined_statement

preparable_SQL_data_statement ::=
             delete_statement_searched
     |       dynamic_single_row_select_statement
     |       insert_statement
     |       dynamic_select_statement
     |       update_statement_searched
     |       preparable_dynamic_delete_statement_positioned
     |       preparable_dynamic_update_statement_positioned

dynamic_single_row_select_statement ::= query_specification

dynamic_select_statement ::= cursor_specification

preparable_dynamic_delete_statement_positioned ::=
    "DELETE" <space>
    [ "FROM" <space> table_name <space> ]
    "WHERE" <space> "CURRENT" <space> "OF" <space> cursor_name

preparable_dynamic_update_statement_positioned ::=
    "UPDATE" <space>
    [ table_name <space> ]
    "SET" <space> set_clause
    "WHERE" <space> "CURRENT" <space> "OF" <space> cursor_name

preparable_SQL_schema_statement ::= SQL_schema_statement

preparable_SQL_transaction_statement ::= SQL_transaction_statement

preparable_SQL_session_statement ::= SQL_session_statement

(*
preparable_SQL_implementation_defined_statement ::= !! See the syntax rules
*)

preparable_SQL_implementation_defined_statement ::= do_not_care

direct_SQL_data_statement ::=
             delete_statement_searched
     |       direct_select_statement_multiple_rows
     |       insert_statement
     |       update_statement_searched
     |       temporary_table_declaration

direct_select_statement_multiple_rows ::=
    query_expression [ order_by_clause ]

(*
direct_implementation_defined_statement ::= !! See the syntax rules
*)

direct_implementation_defined_statement ::= do_not_care

SQL_object_identifier ::= SQL_provenance SQL_variant

SQL_provenance ::= arc1 arc2 arc3

arc1 ::=
    "iso"
  | "1"
  | "iso" <zspace> left_paren <zspace> "1" <zspace> right_paren

arc2 ::=
    "standard"
  | "0"
  | "standard" <zspace> left_paren <zspace> "0" <zspace> right_paren

arc3 ::= "9075"

SQL_variant ::= SQL_edition SQL_conformance

SQL_edition ::= 1987 | 1989 | 1992

1987 ::=
    "0"
  | "edition1987" <zspace> left_paren <zspace> "0" <zspace> right_paren

1989 ::= 1989_base 1989_package

1989_base ::=
    "1"
  | "edition1989" <zspace> left_paren <zspace> "1" <zspace> right_paren

1989_package ::= integrity_no | integrity_yes

integrity_no ::=
    "0"
  | "IntegrityNo" <zspace> left_paren <zspace> "0" <zspace> right_paren

integrity_yes ::=
    "1"
  | "IntegrityYes" <zspace> left_paren <zspace> "1" <zspace> right_paren

1992 ::=
    "2"
  | "edition1992" <zspace> left_paren <zspace> "2" <zspace> right_paren

SQL_conformance ::= low | intermediate | high

low ::=
    "0"
  | "Low" <zspace> left_paren <zspace> "0" <zspace> right_paren

intermediate ::=
    "1"
  | "Intermediate" <zspace> left_paren <zspace> "1" <zspace> right_paren

high ::=
    "2"
  | "High" <zspace> left_paren <zspace> "2" <zspace> right_paren
